package dev.ethanwu.testutil

import org.junit.jupiter.api.DynamicTest
import java.util.stream.Stream
import kotlin.streams.asStream

private const val SEPARATOR = " "

private typealias TransformationFunction<Args, Result> = (Args) -> Result
private typealias TransformationElement<Args, Result> = Pair<String, TransformationFunction<Args, Result>>
private typealias Transformation<Args, Result> = List<TransformationElement<Args, Result>>

class TestCaseGenerator<Result> private constructor(private val cases: Transformation<Unit, Result>) {

    private constructor(baseName: String, func: (Unit) -> Result) : this(listOf(Pair(baseName, func)))

    companion object {
        /**
         * Create a [TestCaseGenerator] initialized with the given test case name.
         *
         * @param baseName the base name for test cases generated by this generator
         */
        @JvmStatic
        @JvmOverloads
        fun create(baseName: String = ""): TestCaseGenerator<Unit> {
            return TestCaseGenerator(baseName) { }
        }

        /**
         * Create a [TestCaseGenerator] initialized with the given initial data (and optional
         * base name).
         *
         * @param seed the initial data to use for chained transformations
         * @param baseName the base name for test cases generated by this generator
         */
        @JvmStatic
        fun <Result> create(seed: Result, baseName: String = ""): TestCaseGenerator<Result> {
            return TestCaseGenerator(baseName) { seed }
        }

        /**
         * Create a [TestCaseGenerator] from a list of name and initial data pairs.
         *
         * @param elements the initial data values to use for chained transformations
         */
        @JvmStatic
        fun <Result> create(elements: Iterable<Pair<String, Result>>): TestCaseGenerator<Result> {
            return TestCaseGenerator(elements.map { el -> Pair(el.first, { el.second }) })
        }

        /**
         * Create a [TestCaseGenerator] from a list of name and initial data pairs.
         *
         * @param elements the initial data values to use for chained transformations
         */
        @JvmStatic
        fun <Result> create(vararg elements: Pair<String, Result>): TestCaseGenerator<Result> {
            return create(elements.asIterable())
        }
    }

    /**
     * Add a set of transformations to the generator chain.
     *
     * Elements of [next] are [Pair]s consisting of the string to append to the test's display name,
     * and the function to do the actual transformation. The transformation function takes the
     * current data as its only argument, and returns the new data.
     *
     * @param next the transformations to add
     */
    fun <NewResult> join(next: Iterable<TransformationElement<Result, NewResult>>): TestCaseGenerator<NewResult> {
        return TestCaseGenerator(cases.flatMap { (name, func) ->
            next.map { (nextName, nextFunc) ->
                val newName = if (name == "" || nextName == "") {
                    name + nextName
                } else {
                    name + SEPARATOR + nextName
                }
                Pair(newName, { nextFunc(func(Unit)) })
            }
        })
    }

    /**
     * Add a set of transformations to the generator chain.
     *
     * Elements of [next] are [Pair]s consisting of the string to append to the test's display name,
     * and the function to do the actual transformation. The transformation function takes the
     * current data as its only argument, and returns the new data.
     *
     * @param next the transformations to add
     */
    fun <NewResult> join(vararg next: TransformationElement<Result, NewResult>): TestCaseGenerator<NewResult> {
        return join(next.asIterable())
    }

    /**
     * Add an unconditional transformation to the generator.
     *
     * The transformation function takes the current data as its only argument, and returns the
     * new data.
     *
     * Equivalent to [`join`][join]`(Pair("", func))`.
     *
     * @param func the transformation to add
     */
    fun <NewResult> join(func: (Result) -> NewResult): TestCaseGenerator<NewResult> {
        return join(listOf(Pair("", func)))
    }


    /**
     * Finish the test case generation by executing a function to run tests with the
     * generated data.
     *
     * Returns a stream of [DynamicTest]s
     *
     * Equivalent to [`join`][join]`(func).`[`toDynamicTestStream`][toDynamicTestStream]`()`
     *
     * @param func the function to run tests on the generated data
     */
    fun execute(func: (Result) -> Unit): Stream<DynamicTest> {
        return join(func).toDynamicTestStream()
    }

    /**
     * Convert this generator to a [DynamicTest] stream
     */
    fun toDynamicTestStream(): Stream<DynamicTest> {
        return cases.asSequence().map { (name, func) ->
            DynamicTest.dynamicTest(name) { func(Unit) }
        }.asStream()
    }
}

